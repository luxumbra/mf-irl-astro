---
import { SITE } from "~/config.mjs";
import { getCanonical, getHomePermalink } from "~/utils/permalinks";
import Layout from "~/layouts/PageLayout.astro";
import ThreeD from "~/components/widgets/ThreeD";
import SponsorsSection from "~/components/core/SponsorsSection.astro";
import Markdown from "@astrojs/markdown-component";
import { DateTime } from "luxon";
import socialImage from "~/assets/images/socials/metafest-shared.jpg";
import Plants from "~/components/widgets/Plants.astro";
import { fetchCalendarData } from "~/utils/fetchCalendarEvents";
import { Icon } from "@iconify/react";
// import { AddToCalendarButton as AddToCalButton } from 'add-to-calendar-button-react';
import clsx from "clsx";
import "~/components/widgets/schedule-tabs.css";
import ScheduleItem from "~/components/atoms/ScheduleItem.astro";
import ScheduleItemAlt from "~/components/atoms/ScheduleItemAlt.astro";
import { days } from "~/content/schedule";
import * as bustripContent from "~/content/schedule/schedule-bustrip.md";

import type { ScheduleEventType } from "~/content/schedule";

type TabType = {
  name: string;
  date: TabDateType;
  data: [] | ScheduleEventType[] | any;
};

type TabDateType = {
  from: string;
  to: string;
};

// type EventDayType = {
//   location: string;
//   events: [];
// };

const getCalForBuild = await fetchCalendarData();
const filterDataForTabs = () => {
  if (!getCalForBuild) return;
  const tabs: TabType[] = [
    {
      name: "Warmup Days",
      date: {
        from: "2023-08-11",
        to: "2023-08-15",
      },
      data: [] as ScheduleEventType[],
    },
    {
      name: "Meta/Regen Day",
      date: {
        from: "2023-08-16",
        to: "2023-08-16",
      },
      data: [],
    },
    {
      name: "Coordination/Meta Day",
      date: {
        from: "2023-08-17",
        to: "2023-08-17",
      },
      data: [],
    },
    {
      name: "Unconference Day",
      date: {
        from: "2023-08-18",
        to: "2023-08-18",
      },
      data: [],
    },
    {
      name: "Bus Trip",
      date: {
        from: "2023-08-19",
        to: "2023-08-24",
      },
      data: [] as ScheduleEventType[],
    },
  ];

  const metaRegenDayGrouped = getCalForBuild.data.reduce(
    (grouped: any, event: any) => {
      const day = DateTime.fromISO(event.start.dateTime).toLocaleString(
        DateTime.DATE_SHORT
      );
      if (day.includes("8/16/2023")) {
        (grouped[event.location] = grouped[event.location] || []).push(event);
      }

      return grouped;
    },
    {}
  );

  const coordinationDAODayGrouped = getCalForBuild.data.reduce(
    (grouped: any, event: any) => {
      const day = DateTime.fromISO(event.start.dateTime).toLocaleString(
        DateTime.DATE_SHORT
      );
      if (day.includes("8/17/2023")) {
        (grouped[event.location] = grouped[event.location] || []).push(event);
      }

      return grouped;
    },
    {}
  );

  const unconferenceGrouped = getCalForBuild.data.reduce(
    (grouped: any, event: any) => {
      const day = DateTime.fromISO(event.start.dateTime).toLocaleString(
        DateTime.DATE_SHORT
      );
      if (day.includes("8/18/2023")) {
        (grouped[event.location] = grouped[event.location] || []).push(event);
      }

      return grouped;
    },
    {}
  );

	const warmupDaysEvents = getCalForBuild.data.filter((event) => {
		const eventDate = DateTime.fromISO(event.start.dateTime);

		if (eventDate.day >= 11 && eventDate.day <= 15) {
			return event;
		}
	});

  // filter data for tabs *Meta/Regen Day*, *Coordination/DAO Day*, *The Unconference*
  const metaRegenDay = getCalForBuild.data.filter((event) => {
		const eventDate = DateTime.fromISO(event.start.dateTime);

    if (eventDate.day === 16 && eventDate.month === 8) {
      return event;
    }
  });

  const coordinationDAODay = getCalForBuild.data.filter((event) => {
		const eventDate = DateTime.fromISO(event.start.dateTime);

    if (eventDate.day === 17 && eventDate.month === 8) {
      return event;
    }
  });

  const unconference = getCalForBuild.data.filter((event) => {
		const eventDate = DateTime.fromISO(event.start.dateTime);

    if (eventDate.day === 18 && eventDate.month === 8) {
      return event;
    }
  });

  const warmupDays: ScheduleEventType[] = days.filter((event) => {
    if (event.grouping === "warmup") {
      return event;
    }
  });

  const bustripDays: ScheduleEventType[] = days.filter((event) => {
    if (event.grouping === "bustrip") {
      return event;
    }
  });

  if (warmupDays.length > 0) {
    tabs[0].data = warmupDays;

		// if (warmupDaysEvents.length > 0) {
		// 	tabs[0].data = warmupDaysEvents;
		// }
  }

  if (metaRegenDay.length > 0) {
    tabs[1].data = metaRegenDay;
  }
  if (coordinationDAODay.length > 0) {
    tabs[2].data = coordinationDAODay;
  }
  if (unconference.length > 0) {
    tabs[3].data = unconference;
  }
  if (bustripContent) {
    tabs[4].data = bustripContent;
  }

  return {
    metaRegenDay,
    coordinationDAODay,
    unconference,
    warmupDays,
    bustripDays,
    tabs: tabs,
  };
};

const tabData = filterDataForTabs();

const meta = {
  title: `${SITE.title}: Full schedule of events`,
  description: "The full schedule of events for MetaFest: Croatia. ",
  canonical: getCanonical(getHomePermalink()),
};
---

<Layout {meta}>
  <div class="pt-16 xl:pt-32"></div>
  <SponsorsSection
    title="Festival Schedule"
    precis="The festival will be held over 3 days, with a variety of events, workshops, and talks. see below..."
    full
    mega
  >
    <div
      class="tabs tabs--horizontal schedule-wrapper w-full mt-8 xl:mt-0 relative mb-32 2xl:mb-80"
    >
      <ol class="tablist schedule-filters flex items-end w-full" role="tablist">
        {
          tabData?.tabs &&
            tabData.tabs.map((tab: TabType, index: number) => {
              const displayDate =
                tab.date.from === tab.date.to
                  ? `${DateTime.fromISO(tab.date.from).toFormat(
                      "d"
                    )} ${DateTime.fromISO(tab.date.from).toFormat("LLL")}`
                  : `${DateTime.fromISO(tab.date.from).toFormat(
                      "d"
                    )} - ${DateTime.fromISO(tab.date.to).toFormat(
                      "d"
                    )} ${DateTime.fromISO(tab.date.to).toFormat("LLL")}`;

              return (
                <li role="presentation" class="tab">
                  <a
                    href={`#tab-section-${index + 1}`}
                    id={`tab${index + 1}`}
                    role="tab"
                    aria-selected={index === 0 ? "true" : "false"}
                    class="text-2xl text-gradient flex flex-col px-3 py-2"
                  >
                    <span class="font-bold">{tab.name}</span>
                    <span>{displayDate}</span>
                  </a>
                </li>
              );
            })
        }
      </ol>
      <div
        class={clsx(
          "tab-content mb-32 flex-nowrap w-full relative overflow-hidden"
          // `grid-cols-${tabData?.tabs.length}`
        )}
      >
        {
          tabData?.tabs &&
            tabData?.tabs.map((tab: TabType, index: number) => {
							index === 0 && console.log('tab', tab.data);
              return (
                <div
                  class={clsx(
                    "tab-section w-full overflow-y-hidden",
                    index === 0 ? "active" : "",
                    typeof tab.data === "string" && "tab-section--md"
                  )}
                  id={`tab-section-${index + 1}`}
                  tabindex="-1"
                  role="tabpanel"
                  aria-labelledby={`tab${index + 1}`}
                  aria-hidden={index === 0 ? "false" : "true"}
                  hidden={index === 0 ? false : true}
                >
									{index === 0 && tab.data && tab.data.length > 0 && (
										<div class="max-w-3xl mx-auto prose prose-sm xl:prose-lg prose-h3:text-accent-light-alpha-90 prose-img:mx-auto">
											{tab.data.map((event: any) => {
												return <p>{JSON.stringify(event)}</p>;
											})}
										</div>
									)}
                  {index > 0 && tab.data && tab.data.length > 0 ? (
                    <ol
                      class={clsx(
                        "schedule__list tiers flex flex-col xl:grid xl:grid-cols-3 gap-x-0 gap-y-5 xl:gap-5 items-stretch w-full"
                      )}
                    >
                      {tab.data.map((event: any) => {
                        if (event.grouping !== undefined) {
                          return <ScheduleItemAlt event={event} />;
                        }

                        return <ScheduleItem event={event} />;
                      })}
                    </ol>
                  ) : (
                    <>
                      {tab.data && tab.data.rawContent ? (
												<div class="max-w-3xl mx-auto prose prose-sm xl:prose-lg prose-h3:text-accent-light-alpha-90 prose-img:mx-auto">
                        <Markdown>{tab.data.rawContent}</Markdown>
												</div>
                      ) : (
                        <div class="flex flex-col items-center justify-center w-full h-full">
                          <p class="text-xl font-bold text-center">
                            Awaiting content for this day. Check back later.{" "}
                          </p>
                        </div>
                      )}
                    </>
                  )}
                </div>
              );
            })
        }
      </div>
    </div>
  </SponsorsSection>

  <div
    class="absolute h-[50vh] w-full overflow-y-visible z-[9] inset-0 top-auto"
  >
    <div
      class="relative w-full h-full"
      x-data="{shown: false}"
      x-intersect:once="shown = true"
    >
      <Plants />
    </div>
  </div>
  <ThreeD client:visible />
</Layout>

<script>
  const tablist = document.querySelector("[role='tablist']") as HTMLElement;
  const tabs = Array.from(tablist.querySelectorAll("a")) as HTMLElement[];
  const tabContainer = document.querySelector(".tab-content") as HTMLElement;
  // eslint-disable-next-line no-undef
  const panels = document.querySelectorAll(
    ".tab-section[role='tabpanel']"
  ) as NodeListOf<HTMLElement>;
  const heights: number[] = panels.forEach(
    (panel) => panel.offsetHeight
  ) as any;
  console.log({ heights });
  const LEFT_ARROW = "leftarrow";
  const RIGHT_ARROW = "rightarrow";
  const DOWN_ARROW = "downarrow";

  const switchTab = (oldTab: HTMLElement, newTab: HTMLElement) => {
    newTab.focus();
    newTab.removeAttribute("tabindex");
    newTab.setAttribute("aria-selected", "true");

    oldTab.removeAttribute("aria-selected");
    oldTab.setAttribute("tabindex", "-1");
    // console.log(panels[tabs.indexOf(newTab)].offsetHeight);
    panels[tabs.indexOf(oldTab)].hidden = true;
    panels[tabs.indexOf(newTab)].hidden = false;
    panels[tabs.indexOf(oldTab)].ariaHidden = "true";
    panels[tabs.indexOf(newTab)].ariaHidden = "false";
    panels[tabs.indexOf(newTab)].classList.add("active");
    panels[tabs.indexOf(oldTab)].classList.remove("active");
  };

  window.addEventListener(
    "load",
    () => {
      tabs.forEach((tab, i) => {
        tab.addEventListener("click", (e) => {
          e.preventDefault();
          let currentTab = tablist.querySelector(
            "[aria-selected]"
          ) as HTMLElement;
          if (e.currentTarget !== currentTab) {
            switchTab(currentTab, e.currentTarget as HTMLElement);
          }
        });

        tab.addEventListener(
          "keydown",
          (e) => {
            const index = tabs.indexOf(e.currentTarget as HTMLElement);
            if (e.key === DOWN_ARROW) {
              e.preventDefault();
              panels[i].focus();
            }

            if (e.key === LEFT_ARROW) {
              e.preventDefault();
              if (tabs[index - 1]) {
                switchTab(e.currentTarget as HTMLElement, tabs[index - 1]);
              }
            }

            if (e.key === RIGHT_ARROW) {
              e.preventDefault();
              if (tabs[index + 1]) {
                switchTab(e.currentTarget as HTMLElement, tabs[index + 1]);
              }
            }
          },
          { passive: true }
        );
      });
    },
    { passive: true }
  );
</script>

<!-- <script type="module">
  const fetchSchedule = async () => {
    const response = await fetch('/.netlify/functions/fetch-schedule');
    const scheduleData = await response.json();

    // update the page with the new data
    const scheduleElement = document.getElementById('schedule');
    if (!scheduleElement) return;
    const listElement = scheduleElement.querySelector('ol');
    if (!listElement) return;
    listElement.innerHTML = scheduleData
      .map(
        (event) => `
			<li>
				<h3>${event.title}</h3>
				<p>${event.date}</p>
			</li>
		`
      )
      .join('');
  };

  fetchSchedule();

  setInterval(fetchSchedule, 0.5 * 60 * 1000);
</script> -->
